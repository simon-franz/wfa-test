/* tslint:disable */
/* eslint-disable */
/**
 * HR WORKS API v2
 * HR WORKS API v2
 *
 * The version of the OpenAPI document: 2.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiError,
  ExpenseReport,
  ExpenseReportStatus,
  ExpenseReportsDateIntervalData,
  Interval,
  ListReceiptTypesResponse,
  PersonIdentifierType,
  ReceiptCategory,
  TravelRequest,
  TravelRequestStatus,
  TravelRequestsDateIntervalData,
} from '../models/index';
import {
    ApiErrorFromJSON,
    ApiErrorToJSON,
    ExpenseReportFromJSON,
    ExpenseReportToJSON,
    ExpenseReportStatusFromJSON,
    ExpenseReportStatusToJSON,
    ExpenseReportsDateIntervalDataFromJSON,
    ExpenseReportsDateIntervalDataToJSON,
    IntervalFromJSON,
    IntervalToJSON,
    ListReceiptTypesResponseFromJSON,
    ListReceiptTypesResponseToJSON,
    PersonIdentifierTypeFromJSON,
    PersonIdentifierTypeToJSON,
    ReceiptCategoryFromJSON,
    ReceiptCategoryToJSON,
    TravelRequestFromJSON,
    TravelRequestToJSON,
    TravelRequestStatusFromJSON,
    TravelRequestStatusToJSON,
    TravelRequestsDateIntervalDataFromJSON,
    TravelRequestsDateIntervalDataToJSON,
} from '../models/index';

export interface GetTravelExpenseRequest {
    number: string;
}

export interface GetTravelRequestRequest {
    number: string;
}

export interface ListExpenseReportsRequest {
    beginDate: string;
    endDate: string;
    personIdentifierType?: PersonIdentifierType;
    persons?: Array<string>;
    statusFilter?: Array<ExpenseReportStatus>;
    usePersonnelNumbers?: boolean;
    includeExpenseReportsWithoutTrip?: boolean;
    interval?: Interval;
    onlyActive?: boolean;
    page?: number;
}

export interface ListReceiptTypesRequest {
    countryCodes?: Array<string>;
    onlyActive?: boolean;
    categories?: Array<ReceiptCategory>;
}

export interface ListTravelRequestsRequest {
    beginDate: string;
    endDate: string;
    personIdentifierType?: PersonIdentifierType;
    persons?: Array<string>;
    statusFilter?: Array<TravelRequestStatus>;
    usePersonnelNumbers?: boolean;
    interval?: Interval;
    onlyActive?: boolean;
    page?: number;
}

/**
 * TravelExpensesApi - interface
 * 
 * @export
 * @interface TravelExpensesApiInterface
 */
export interface TravelExpensesApiInterface {
    /**
     * Return the data of a specific travel expense report by the given unique number.
     * @summary GET Single Expense Report
     * @param {string} number The unique identifier of the travel expense report. Consists of the person\&#39;s personnel number before and the trip number after the dash symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensesApiInterface
     */
    getTravelExpenseRaw(requestParameters: GetTravelExpenseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExpenseReport>>;

    /**
     * Return the data of a specific travel expense report by the given unique number.
     * GET Single Expense Report
     */
    getTravelExpense(requestParameters: GetTravelExpenseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExpenseReport>;

    /**
     * Return the data of a specific travel request by the given unique number.
     * @summary GET Single Travel Request
     * @param {string} number The unique identifier of the travel request. Consists of the person\&#39;s personnel number before and the trip request number after the dash symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensesApiInterface
     */
    getTravelRequestRaw(requestParameters: GetTravelRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TravelRequest>>;

    /**
     * Return the data of a specific travel request by the given unique number.
     * GET Single Travel Request
     */
    getTravelRequest(requestParameters: GetTravelRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TravelRequest>;

    /**
     * Returns a list of expense reports for the specified persons in the specified date interval.
     * @summary GET Expense Reports
     * @param {string} beginDate The starting date of the date interval. Note: The maximum date interval is one year.
     * @param {string} endDate The end date of the date interval. Note: The maximum date interval is one year.
     * @param {PersonIdentifierType} [personIdentifierType] Specifies the type of identifiers in the persons parameter. Default is personId.
     * @param {Array<string>} [persons] The identifiers of the persons to display data for. Use personIdentifierType to specify what type the values are.
     * @param {Array<ExpenseReportStatus>} [statusFilter] If specified, only expense reports matching one of the selected status values will be returned.
     * @param {boolean} [usePersonnelNumbers] Deprecated - use personIdentifierType instead. If set to true, the API will assume the strings in the persons parameter to represent personnel numbers instead of HR WORKS usernames.
     * @param {boolean} [includeExpenseReportsWithoutTrip] If set to true, the API response will include expense reports that are not associated with a physical trip and represent a collection of receipts.
     * @param {Interval} [interval] Indicates whether the date interval should be split into smaller intervals like weeks or months. If this parameter is not set, the interval will not be split. Setting this parameter to \&quot;days\&quot; will shorten the maximum allowed interval size to 31 days. Note: The API does not perform any date interval adjustments. E.g., even if \&quot;weeks\&quot; was specified for the interval parameter, if the date interval specified by beginDate and endDate spans only two days, the data will only be computed for this two-day span. However, if those two days happen to be Monday and Sunday of different weeks, the result will be split accordingly.
     * @param {boolean} [onlyActive] Set this parameter to false to return persons that have left the company and were set to gone in HR WORKS as well. Note: Deleted persons cannot be returned as the data was removed from HR WORKS. This parameter will be ignored if persons are specified directly via the persons parameter.
     * @param {number} [page] Set this parameter to access a specific page of results. If the parameter is not set, the first page of results is returned. The API returns paging information via the Link header. The page size for this API call is 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensesApiInterface
     */
    listExpenseReportsRaw(requestParameters: ListExpenseReportsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<ExpenseReportsDateIntervalData>; }>>;

    /**
     * Returns a list of expense reports for the specified persons in the specified date interval.
     * GET Expense Reports
     */
    listExpenseReports(requestParameters: ListExpenseReportsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<ExpenseReportsDateIntervalData>; }>;

    /**
     * Returns a list of receipt types.
     * @summary GET Receipt Types
     * @param {Array<string>} [countryCodes] An array of ISO 3166-1 alpha-3 country codes (e.g. DEU, IRL, USA) for which to return data. If not specified, data for all countries in the HR WORKS company will be returned. Country codes for which no corresponding country is found will be omitted.
     * @param {boolean} [onlyActive] Set this parameter to false to also return receipt types that are not active.
     * @param {Array<ReceiptCategory>} [categories] If specified, only receipt types matching one of the selected categories will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensesApiInterface
     */
    listReceiptTypesRaw(requestParameters: ListReceiptTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListReceiptTypesResponse>>;

    /**
     * Returns a list of receipt types.
     * GET Receipt Types
     */
    listReceiptTypes(requestParameters: ListReceiptTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListReceiptTypesResponse>;

    /**
     * Returns a list of travel requests for the specified persons in the specified date interval.
     * @summary GET Travel Requests
     * @param {string} beginDate The starting date of the date interval. Note: The maximum date interval is one year.
     * @param {string} endDate The end date of the date interval. Note: The maximum date interval is one year.
     * @param {PersonIdentifierType} [personIdentifierType] Specifies the type of identifiers in the persons parameter. Default is personId.
     * @param {Array<string>} [persons] The identifiers of the persons to display data for. Use personIdentifierType to specify what type the values are.
     * @param {Array<TravelRequestStatus>} [statusFilter] If specified, only travel requests matching one of the selected status values will be returned.
     * @param {boolean} [usePersonnelNumbers] Deprecated - use personIdentifierType instead. If set to true, the API will assume the strings in the persons parameter to represent personnel numbers instead of HR WORKS usernames.
     * @param {Interval} [interval] Indicates whether the date interval should be split into smaller intervals like weeks or months. If this parameter is not set, the interval will not be split. Setting this parameter to \&quot;days\&quot; will shorten the maximum allowed interval size to 31 days. Note: The API does not perform any date interval adjustments. E.g., even if \&quot;weeks\&quot; was specified for the interval parameter, if the date interval specified by beginDate and endDate spans only two days, the data will only be computed for this two-day span. However, if those two days happen to be Monday and Sunday of different weeks, the result will be split accordingly.
     * @param {boolean} [onlyActive] Set this parameter to false to return persons that have left the company and were set to gone in HR WORKS as well. Note: Deleted persons cannot be returned as the data was removed from HR WORKS. This parameter will be ignored if persons are specified directly via the persons parameter.
     * @param {number} [page] Set this parameter to access a specific page of results. If the parameter is not set, the first page of results is returned. The API returns paging information via the Link header. The page size for this API call is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TravelExpensesApiInterface
     */
    listTravelRequestsRaw(requestParameters: ListTravelRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<TravelRequestsDateIntervalData>; }>>;

    /**
     * Returns a list of travel requests for the specified persons in the specified date interval.
     * GET Travel Requests
     */
    listTravelRequests(requestParameters: ListTravelRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<TravelRequestsDateIntervalData>; }>;

}

/**
 * 
 */
export class TravelExpensesApi extends runtime.BaseAPI implements TravelExpensesApiInterface {

    /**
     * Return the data of a specific travel expense report by the given unique number.
     * GET Single Expense Report
     */
    async getTravelExpenseRaw(requestParameters: GetTravelExpenseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExpenseReport>> {
        if (requestParameters['number'] == null) {
            throw new runtime.RequiredError(
                'number',
                'Required parameter "number" was null or undefined when calling getTravelExpense().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerJWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v2/travel-expenses/expense-reports/{number}`;
        urlPath = urlPath.replace(`{${"number"}}`, encodeURIComponent(String(requestParameters['number'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExpenseReportFromJSON(jsonValue));
    }

    /**
     * Return the data of a specific travel expense report by the given unique number.
     * GET Single Expense Report
     */
    async getTravelExpense(requestParameters: GetTravelExpenseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExpenseReport> {
        const response = await this.getTravelExpenseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the data of a specific travel request by the given unique number.
     * GET Single Travel Request
     */
    async getTravelRequestRaw(requestParameters: GetTravelRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TravelRequest>> {
        if (requestParameters['number'] == null) {
            throw new runtime.RequiredError(
                'number',
                'Required parameter "number" was null or undefined when calling getTravelRequest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerJWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v2/travel-expenses/travel-requests/{number}`;
        urlPath = urlPath.replace(`{${"number"}}`, encodeURIComponent(String(requestParameters['number'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TravelRequestFromJSON(jsonValue));
    }

    /**
     * Return the data of a specific travel request by the given unique number.
     * GET Single Travel Request
     */
    async getTravelRequest(requestParameters: GetTravelRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TravelRequest> {
        const response = await this.getTravelRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of expense reports for the specified persons in the specified date interval.
     * GET Expense Reports
     */
    async listExpenseReportsRaw(requestParameters: ListExpenseReportsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<ExpenseReportsDateIntervalData>; }>> {
        if (requestParameters['beginDate'] == null) {
            throw new runtime.RequiredError(
                'beginDate',
                'Required parameter "beginDate" was null or undefined when calling listExpenseReports().'
            );
        }

        if (requestParameters['endDate'] == null) {
            throw new runtime.RequiredError(
                'endDate',
                'Required parameter "endDate" was null or undefined when calling listExpenseReports().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['personIdentifierType'] != null) {
            queryParameters['personIdentifierType'] = requestParameters['personIdentifierType'];
        }

        if (requestParameters['persons'] != null) {
            queryParameters['persons'] = requestParameters['persons'];
        }

        if (requestParameters['statusFilter'] != null) {
            queryParameters['statusFilter'] = requestParameters['statusFilter'];
        }

        if (requestParameters['beginDate'] != null) {
            queryParameters['beginDate'] = requestParameters['beginDate'];
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['endDate'] = requestParameters['endDate'];
        }

        if (requestParameters['usePersonnelNumbers'] != null) {
            queryParameters['usePersonnelNumbers'] = requestParameters['usePersonnelNumbers'];
        }

        if (requestParameters['includeExpenseReportsWithoutTrip'] != null) {
            queryParameters['includeExpenseReportsWithoutTrip'] = requestParameters['includeExpenseReportsWithoutTrip'];
        }

        if (requestParameters['interval'] != null) {
            queryParameters['interval'] = requestParameters['interval'];
        }

        if (requestParameters['onlyActive'] != null) {
            queryParameters['onlyActive'] = requestParameters['onlyActive'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerJWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v2/travel-expenses/expense-reports`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns a list of expense reports for the specified persons in the specified date interval.
     * GET Expense Reports
     */
    async listExpenseReports(requestParameters: ListExpenseReportsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<ExpenseReportsDateIntervalData>; }> {
        const response = await this.listExpenseReportsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of receipt types.
     * GET Receipt Types
     */
    async listReceiptTypesRaw(requestParameters: ListReceiptTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListReceiptTypesResponse>> {
        const queryParameters: any = {};

        if (requestParameters['countryCodes'] != null) {
            queryParameters['countryCodes'] = requestParameters['countryCodes'];
        }

        if (requestParameters['onlyActive'] != null) {
            queryParameters['onlyActive'] = requestParameters['onlyActive'];
        }

        if (requestParameters['categories'] != null) {
            queryParameters['categories'] = requestParameters['categories'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerJWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v2/travel-expenses/receipt-types`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListReceiptTypesResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of receipt types.
     * GET Receipt Types
     */
    async listReceiptTypes(requestParameters: ListReceiptTypesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListReceiptTypesResponse> {
        const response = await this.listReceiptTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of travel requests for the specified persons in the specified date interval.
     * GET Travel Requests
     */
    async listTravelRequestsRaw(requestParameters: ListTravelRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<TravelRequestsDateIntervalData>; }>> {
        if (requestParameters['beginDate'] == null) {
            throw new runtime.RequiredError(
                'beginDate',
                'Required parameter "beginDate" was null or undefined when calling listTravelRequests().'
            );
        }

        if (requestParameters['endDate'] == null) {
            throw new runtime.RequiredError(
                'endDate',
                'Required parameter "endDate" was null or undefined when calling listTravelRequests().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['personIdentifierType'] != null) {
            queryParameters['personIdentifierType'] = requestParameters['personIdentifierType'];
        }

        if (requestParameters['persons'] != null) {
            queryParameters['persons'] = requestParameters['persons'];
        }

        if (requestParameters['statusFilter'] != null) {
            queryParameters['statusFilter'] = requestParameters['statusFilter'];
        }

        if (requestParameters['beginDate'] != null) {
            queryParameters['beginDate'] = requestParameters['beginDate'];
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['endDate'] = requestParameters['endDate'];
        }

        if (requestParameters['usePersonnelNumbers'] != null) {
            queryParameters['usePersonnelNumbers'] = requestParameters['usePersonnelNumbers'];
        }

        if (requestParameters['interval'] != null) {
            queryParameters['interval'] = requestParameters['interval'];
        }

        if (requestParameters['onlyActive'] != null) {
            queryParameters['onlyActive'] = requestParameters['onlyActive'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerJWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v2/travel-expenses/travel-requests`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns a list of travel requests for the specified persons in the specified date interval.
     * GET Travel Requests
     */
    async listTravelRequests(requestParameters: ListTravelRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<TravelRequestsDateIntervalData>; }> {
        const response = await this.listTravelRequestsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
